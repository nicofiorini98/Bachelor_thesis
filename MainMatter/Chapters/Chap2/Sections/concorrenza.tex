\section{Concorrenza}

La concorrenza è un concetto fondamentale nell'ambito
dello sviluppo software, si riferisce alla capacità
di eseguire più attività contemporaneamente.
Questo è particolarmente importante in applicazione
che devono gestire molteplici operazioni in parallelo
come ad esempio un server web, applicazioni di
elaborazione dati.

La concorrenza consente a un programma di sfruttare appieno
le risorse disponibili, aumentando l'efficienza e migliorando
le prestazioni complessive.
Inoltre, permette di creare sistemi più reattivi e
scalabili, in grado di gestire un numero crescente di
richieste senza compromettere le prestazioni.

In generale, la gestione della concorrenza può essere complessa
e soggetta a errori o comportamenti indeterminati, infatti,
più processi o thread possono interagire tra loro in modo
imprevedibile, essendo così costretti a usare tecniche di
locking in concomitanza di memoria condivisa trà più thread.

Nel contesto di Elixir, la concorrenza è un concetto centrale
e viene gestita attraverso il modello di programmazione
basato su processi leggeri, tutti isolati tra loro con il proprio
stack ed il proprio heap.

% ------------------------------------------------------

\subsection{La concorrenza in Beam}

La concorrenza gioca un ruolo chiave per un software
che vuole essere altamente responsivo.
La concorrenza fa uso dei cosiddetti processi leggeri
nella piattaforma Erlang, non sono processi del 
sistema operativo, ma processi della
VM, chiamato processo e non thread in quanto non
condividono memoria tra di loro e sono completamente
isolati.

Un server tipico deve gestire migliaia di richieste, e
gestirle concorrenzialmente è essenziale per non far
rimanere in attesa il client. Quello che si vuole è
gestirli parallelamente il più possibile sfruttando
più risorse della Cpu disponibile.
Quello che fa la macchina virtuale per noi è permetterci
la scalabilità,più richieste allora più risorse da allocare.

Inoltre, siccome il processo è isolato, un errore in una richiesta
può essere localizzato senza avere impatto
sul resto del sistema, così creando anche un sistema robusto
agli errori.

Un processo appena creato occupa in memoria 326 words \cite{ErlangPr21:online},
quindi in una macchina a 64 bit occupa 2608 byte.
Lo si può vedere in Elixir facilmente nell'esempio 
% \ref{lst:memoryoneprocess}

\begin{lstlisting}[language=elixir, caption={Memoria in un processo},captionpos=b,
	label={lst:memoryoneprocess}]
defmodule Examples.Memory do
  def mypid do
    receive do
      :stop -> :exit
    end
  end
 
  def benchmark do
    pid = spawn(fn -> mypid() end)
    {_,byte_used} = :erlang.process_info(pid,:memory)
    IO.puts("La memoria usata dal processo e': #{byte_used} byte")
    send pid, :stop
  end
end
\end{lstlisting}

Infatti l'output ottenuto dall'esempio \ref{lst:memoryoneprocess}
\begin{lstlisting}[language=none]
iex> Examples.Memory.benchmark
La memoria usata dal processo e': 2640 byte
:stop
\end{lstlisting}
	
Si nota dall'output dell'esempio che la memoria utilizzata
è leggermente superiore della memoria minima dichiarata,
infatti il processo non fa nulla di particolare oltre
ad aspettare il messaggio di ":stop".
È da notare che è proprio questa leggerezza nei processi che
permette al linguaggio di essere orientato alla concorrenza,
e poter usare i processi con più leggerezza rispetto
ad altri meccanismi di altri linguaggi che usano i thread,
Un altro punto da notare è che si può migliorare significativamente
la reattività del programma ma non l'efficienza totale del
sistema, infatti non tutti i processi
sono eseguiti in parallelo, infatti in una macchina con quattro
processori non si possono eseguire più di 4 processi per volta
ed in un normale software Elixir è normale avere migliaia di
processi che lavorano.

Facendo un esempio con una Cpu dual-core,
i processi vengono eseguiti concorrenzialmente e gestiti
dagli Scheduler della VM,
in figura \ref{fig:concorrenza_beam} è mostrato come
la VM gestisce i processi di default.

\begin{figure}[!htp]
    \centering
    \includegraphics[keepaspectratio=true,scale=0.25]{images/beam_concurrency.png}
	\caption{Concorrenza nella VM Beam \cite{elixirInAction5}}
  	\label{fig:concorrenza_beam}
\end{figure}


%--------------------------------------------------------------

\subsection{Concorrenza basata su attori}

Elixir usa un modello di concorrenza basato su attori,
Gli attori sono entità di elaborazione indipendenti
che eseguono operazioni in modo asincrono, questi attori
non sono altri che  processi che vengono identificati
attraverso un \textbf{PID} univoco.
Gli attori sono isolati l'uno dall'altro e
comunicano solo attraverso lo scambio di messaggi,
questo scambio avviene attraverso
dei canali di comunicazione detti \textbf{"mailbox"}.
Ogni processo ha una propria mailbox dove avviene la
ricezione del messaggio.

Conoscendo il PID di un processo può avvenire la comunicazione
attraverso la primitiva fornita dal linguaggio.

Un processo può essere creato tramite la primitiva \textbf{spawn/1},

\begin{lstlisting}[language=elixir, caption={Creazione processo},captionpos=b,
	label={lst:creazione_processo}]
iex(1)> pid = spawn(fn -> IO.puts("Hello") end)
Hello
#PID<0.114.0>
\end{lstlisting}
\section{Basi dichiarative}

Come già accennato, Elixir adotta un approccio
dichiarativo nella definizione delle funzioni.
Questo si contrappone all'approccio imperativo,
che si concentra su "come posso risolvere questo problema?",
mentre quello dichiarativo si pone la domanda 
"come posso definire un problema?".

Nell'esempio \ref{lst:somma_n_cpp} è presentato un approccio
imperativo al problema "somma dei primi n elementi", mentre
nell'esempio \ref{lst:somma_n_elixir} è presentato l' approccio dichiarativo
con Elixir.

\renewcommand\lstlistingname{Esempio}

\begin{lstlisting}[language=cpp, caption={Somma N elementi},captionpos=b,
	label={lst:somma_n_cpp}]
int sum_first_n(n){
  int sum=0;
    for(int i=1;i++;i<=n){
      sum+=i;
    }
    return sum;
}
\end{lstlisting}

\begin{lstlisting}[language=elixir, caption={Somma N elementi},captionpos=b,
	label={lst:somma_n_elixir}]
defmodule Sum do
  def sum_recursive(0), do: 0
  def sum_recursive(n), do: n + sum_recursive(n - 1)
end
\end{lstlisting}

In un approccio imperativo bisogna controllare il flusso



